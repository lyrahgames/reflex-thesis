\documentclass{stdlocal}
\begin{document}
\section{Design} % (fold)
\label{sec:design}

\subsection{Polyhedral Surface Data Structure} % (fold)
\label{sub:polyhedral_surface_data_structure}

  In general, the choice and efficiency of algorithms highly depends on underlying data structures that represent the intermediate data of a program \autocite{knuth1997,mehlhorn2008,smed2006}.
  Thus, thorough design considerations for the data structures of polyhedral surfaces and surface mesh curves are mandatory to build fast and robust curve smoothing algorithms.

  The easiest representation, mandatory for the visualization of triangular surface meshes with OpenGL, is to have two separate lists of vertices and faces of a polyhedral surface \autocite{opengl}.
  Each vertex should at least store its position but will most likely also provide  a pseudo-normal and/or texture coordinates for improved rendering and shading capabilities.
  Every face is a triangle, that refers to the three vertices it contains.
  In this case, the order of vertex references determines the orientation of the triangle as described in section~\ref{sec:preliminaries} in the preliminaries.
  % This is the minimal information that needs to be provided to create a polyhedral surface.

  \inputCodeBlock[title = Vertices and Faces]{code/vertices-and-faces.hpp}

  \begin{figure}
    \centering
    \begin{subfigure}[c]{0.35\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/polyhedral-surface-struct-base-scheme.pdf}
    \end{subfigure}
    \hfill
    \begin{subfigure}[c]{0.63\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/polyhedral-surface-struct-base.pdf}
    \end{subfigure}
    \caption[Polyhedral Surface Data Structure]{%
      \textbf{Polyhedral Surface Data Structure}\\
      Scheme and Memory Layout of triangles and vertices
    }
  \end{figure}

  As polyhedral surfaces are a special form of 3D surface geometry, I will use file formats, such as STL \autocite{stl-file-format} and Wavefront OBJ \autocite{obj-file-format}, to provide the possibility for reading complex surface meshes from disk.
  Especially in the area of computer graphics in conjunction with the C++ programming language, the \textit{Assimp} library \autocite{assimp} is often used to load even more file formats that represent general surfaces and scenes.
  The facility makes it possible to test algorithms with very complex surface meshes from the \citetitle{thingi10k} dataset whose models are mainly provided as STL files.

  Up to that point, none of the data representations allows to access the neighbors of vertices or faces.
  As a consequence, it is not possible to move points arbitrarily along the surface which would hinder the implementation of a curve smoothing algorithm based on local optimization.
  So, at least information about the local neighborhood of points need to be generated and stored properly.

  Computing and storing neighbor and adjacency information of surface meshes is a studied and vast area of computational geometry.
  There are multiple well-known data structures, like Quad-Edge Algebras \autocite{guibas1985} and triangular neighbors \autocite{shewchuk1996}, for handling graphs that represent the topological structure of general 2D polyhedral surfaces.
  These data structures have successfully been used to efficiently construct Delaunay triangulations and encode the information of 3D surface meshes.

  !!!!To only generate vertex neighbors is also possible but not as versatile as one can think.!!!!

  Regarding the implementation of surface mesh curves, I will use a flat adjacency list to store references to adjacent triangles of a given triangle in accordance to \textcite{mancinelli2022}.
  As each triangle may at most exhibit three other triangles that are adjacent to it, there is an upper storage bound for neighboring references of each triangle.
  In the case that a triangle is part of the boundary of the polyhedral surface, a non-existing neighbor is marked as an invalid reference.
  This representation also comes in handy for the implementation of parallel smoothing algorithms on the GPU.

  As already described in section~\ref{sec:preliminaries} in the preliminaries, the vertices and edges of a polyhedral surface model a graph which characterizes the vertex adjacencies.
  Looking at a polyhedral surface in this way, storing the triangle adjacencies makes the corresponding dual graph available.
  Using the vertex-based graph, the boundaries of a surface mesh need to be handled by additional facilities as the graph itself does not exhibit a way to encode them.
  On the other hand, its dual graph copes with boundaries by marking references to be invalid.
  Furthermore, adding orientation to the vertex-based graph can be cumbersome whereas the orientation for the triangle-based dual graph is given by orientation of the triangle itself.

  % \inputCodeBlock[title = Polyhedral Surface]{code/polyhedral_surface/polyhedral_surface.hpp}

  Following the specification of the data structure to represent a polyhedral surface, an algorithm for its generation needs to be provided.
  In the context of computer graphics, vertices of a polyhedral surface must differ as soon as they exhibit different positions, pseudo-normals, or texture coordinates because typical OpenGL shaders expect vertices to carry a known size of additional attribute data.
  In the extreme case of STL files, every triangle refers to vertices that cannot be referred by other triangles.
  For curve smoothing on the other hand, the values for pseudo-normals and texture coordinates do not change the topology of the polyhedral surface and are only used to improve the quality of rendering.
  Therefore curve algorithms and their respective data structures would need to ignore different values for pseudo-normals and texture coordinates as long as two vertices have the same position and a resulting topological connection.
  The use of surface mesh curves and smoothing algorithms should not put a higher burden on the OpenGL pipeline or the computer storage.

  To solve this problem, I will use the triangle adjacencies to also encode neighborhoods in the case only the positions of vertices are the same.
  For this, I first add all the vertices to hash map using their position as a key with a custom hash function.
  This allows to find other vertices with the same position in an expected constant time.
  The values of the vertex hash map will be a list of vertex indices referring to the same location in space.

  In a following step, a hash map of directed edges will be constructed with a custom hash function for edges by iterating over the list of faces.
  Hereby, each triangle will add three directed edges.
  The values for each directed edge in the hash map will refer to its specific triangle and location inside that triangle.

  Putting now together the use of the vertex and edge hash maps, the face neighbors can be constructed.
  After the construction of face neighbors, the hash maps for vertices and edges are no longer needed and can be deleted.

  \inputCodeBlock[title = Discrete Quotient Map]{code/discrete-quotient-map.hpp}

  \begin{figure}[h]
    \centering
    \begin{subfigure}[c]{0.40\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/polyhedral-surface-separated.pdf}
    \end{subfigure}
    \hfill
    $\longrightarrow$
    \hfill
    \begin{subfigure}[c]{0.40\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/polyhedral-surface-joint.pdf}
    \end{subfigure}
    \caption[Polyhedral Surface Data Structure]{%
      \textbf{Polyhedral Surface Data Structure}\\
      Scheme and Memory Layout of triangles and vertices
    }
  \end{figure}

  \begin{figure}
    \centering
    \includegraphics[width=\linewidth]{figures/polyhedral-surface-topological-vertex-map.pdf}
    \caption[Polyhedral Surface Data Structure]{%
      \textbf{Polyhedral Surface Data Structure}\\
      Scheme and Memory Layout of triangles and vertices
    }
  \end{figure}

  \inputCodeBlock[title = Topological Vertex Map]{code/topological-vertex-map.hpp}
  \inputCodeBlock[title = Topological Edges]{code/topological-directed-edges.hpp}
  \inputCodeBlock[title = Topological Face Adjacencies]{code/topological-face-adjacencies.hpp}

  \begin{figure}
    \centering
    \begin{subfigure}[b]{0.4\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/quad-edge-edge.pdf}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.4\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/quad-edge-dual.pdf}
    \end{subfigure}
    \caption[Quad-Edge Scheme]{
      \textbf{Quad-Edge Scheme}\\
    }
  \end{figure}

  \begin{figure}[h]
    \centering
    \begin{subfigure}[b]{0.31\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/quad-edge-rot.pdf}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.67\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/quad-edge-struct-rot.pdf}
    \end{subfigure}
    \caption[Quad-Edge Rotation Scheme]{
      \textbf{Quad-Edge Rotation Scheme}\\
    }
  \end{figure}

  \begin{figure}[h]
    \centering
    \begin{subfigure}[c]{0.38\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/polyhedral-surface-triangle-adjacencies.pdf}
    \end{subfigure}
    \hfill
    \begin{subfigure}[c]{0.60\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/polyhedral-surface-triangle-adjacencies-struct.pdf}
    \end{subfigure}
    \caption[Triangle Adjacencies Scheme]{
      \textbf{Triangle Adjacencies Scheme}\\
    }
  \end{figure}

  \begin{figure}[h]
    \centering
    \begin{subfigure}[c]{0.31\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/polyhedral-surface-triangle-adjacencies-rot.pdf}
    \end{subfigure}
    \hfill
    \begin{subfigure}[c]{0.67\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/polyhedral-surface-triangle-adjacencies-rot-struct.pdf}
    \end{subfigure}
    \caption[Triangle Adjacencies Scheme]{
      \textbf{Triangle Adjacencies Scheme}\\
    }
  \end{figure}
% subsection polyhedral_surface_data_structure (end)

Experimenting with various designs and implementations of algorithms, that robustly and efficiently smooth discrete curves on surface meshes, requires us to use a whole program pipeline or framework for loading input data, intuitively working with user interaction, and visualizing any intermediate results.
As changing specific parts of such a pipeline may affect the performance, outcomes, and overall behavior of an algorithm or program, a brief overview over all of its components is essential to allow for reproducible results and will therefore be given in the following subsections.
This will also make it possible for readers to simply reconstruct, adjust, and improve the pipeline for their own domain-specific projects.
Afterwards, I will thoroughly elaborate on the design and implementation of chosen data structures and algorithms together with their mathematical primitives for curve smoothing.

The pipeline or framework, described in this thesis, has been manually implemented with the C++ programming language and the OpenGL graphics API using some external libraries to handle low-level tasks.
Already described in the introduction in section~\ref{sec:introduction}, this choice is well suited for open-source graphics applications and provides programmers with a large freedom when it comes to the implementation of data structures and algorithms.
The complete source code of the project, called \textit{nanoreflex}, is provided as an open-source repository on GitHub.

\subsection{Overview of the Program Pipeline} % (fold)
\label{sub:program_pipeline}
  In the following, the stages of the implemented program pipeline are stated and summarized.
  These stages naturally arise from an insight into the generation and tracing of geodesics on surface meshes, described in section~\ref{sec:previous_work}.
  Locally shortest or straightest geodesics that follow as a solution from the discrete boundary value problem are in some sense the smoothest curves that cannot be made any smoother.
  As we typically need to provide an initial curve for those geodesics to be found, the whole generation and tracing of geodesics can be looked at as an extreme smoothing process.
  Adding parameters to let the user decide on when to stop this process then results in the pipeline given below and schematically shown in figure~\ref{fig:program-pipeline}.

  \begin{figure}[h]
    \begin{center}
      \large
      INSERT YOUR IMAGE HERE!
    \end{center}
    \caption[Program Pipeline Stages]{%
      \textbf{Program Pipeline Stages}\\
      The scheme shows all the stages of the implemented program pipeline.
      The arrows indicate data flow and dependencies.
    }
    \label{fig:program-pipeline}
  \end{figure}

  \begin{enumerate}
    \item \textbf{Surface Mesh Loading:}\\
      Load a surface mesh given by a specific file format from the storage.
    \item \textbf{Surface Mesh Preprocessing:}
      \begin{enumerate}
        \item Generate a connected mesh object to properly model the topology of the input.
        \item Generate the pseudo-normals for each vertex.
        \item Generate the dual graph for the neighbors of each triangle.
        \item Check that the mesh is a valid orientable two-dimensional topological manifold.
      \end{enumerate}
    \item \textbf{Initial Curve Selection:} \\
      Let the user choose an initial curve by drawing on the surface.
    \item \textbf{Parameter Selection:} \\
      Let the user choose parameters for the curve smoothing algorithm.
    \item \textbf{Curve Smoothing:} \\
      Smooth the initial curve according to the constraints given by the selected parameters.
    \item \textbf{Postprocessing:} \\
      Optionally apply the smoothed curve in a domain-specific context.
  \end{enumerate}
  According to figure~\ref{fig:program-pipeline}, the output of every stage is not only forwarded to the next stage but also specifically visualized and rendered to the screen to provide the user with visual feedback and to catch errors or exceptional behavior as early as possible.
  Besides, additional user interactions will be processed for all stages to allow for measurements and adjustments and to be able to react to the output of previous stages.
  The loading of surface meshes from different file formats is typically handled by loader libraries, such as \textit{Assimp}, and will not be further explained.
  On the other hand, surface mesh preprocessing and the initial curve selection are crucial steps in the whole pipeline which remove geometric degeneracies and artifacts that would otherwise violate assertions needed for the correct execution of the algorithm.
  Therefore both stages will be discussed in more detail in the following subsections.
  The postprocessing in our case is optional and only provided for the sake of completeness.
  The parameter selection is highly dependent on the implementation of the curve smoothing algorithm and, as a result, it will be described together with the curve smoothing itself.
% subsection program_pipeline (end)

\subsection{Surface Mesh Preprocessing} % (fold)
\label{sub:mesh_preprocessing}
  The goal of preprocessing a surface mesh which has been loaded from disk is to transform its data into a valid and efficient representation of a polyhedral surface that should exhibit functionality to draw and move points and discrete curves on its surface.
  In the case that this transformation is not possible, the stage at least must check for the validity of the given data and emit an error if there might be any violations.
  % On one hand, the preprocessing of a given surface mesh needs to make sure that the program or algorithm is actually dealing with a valid two-dimensional topological manifold.

  A given Mesh for the algorithm can be quite general.
  Providing triangles which will introduce numerical difficulties is out of the scope of this thesis.

  We will focus on orientable meshes.
  Please note, that is not an actual restriction for the algorithm but will only speed up the implementation.
  Furthermore, we look at surfaces which are the boundary of volumes in three-dimensional Euclidean space which can be looked at as open submanifolds.
  These volumes are therefore by definition oriented and, hence, their boundary needs to be, too.
  Still, we need to look boundaries for surfaces as, for example, distance envelopes restrict the surface without boundary to be one.
  The boundaries need to be handled properly.
  Also, these requirements are only need to hold for the restriction to the distance envelope.
  Often, lines will be drawn on oriented/orientable parts of the surface even if the surface is not orientable due to artifacts originating from scanning or generating meshes.

  \paragraph{Topological Connections}
  We need the topological connections of a given surface mesh.
  In the case of general file formats, a scene is typically separated into multiple meshes which are topologically but not smoothly connected.
  For proper drawing of curves in a whole scene, the topological structure of connections needs to be generated first.
  Using the STL file format, this is not needed.

  \paragraph{Generating the dual graph}
   To generate such a dual graph we refer to this book.
  It is assumed to be a solved problem.
  First, we have created a hash map of oriented edges with a custom hash function to mangle vertex indices.
  The mapped values store the faces indices and their location in the triangle.
  By inverting the indices of a stored edge, one can easily access the neighboring triangle if it exists.
  Furthermore, it is easy to check whether the mesh is oriented and a valid two-dimensional manifold.

  \paragraph{Check for orientability and validity}

% subsection mesh_preprocessing (end)

\subsection{Discrete Surface Curve Data Structure} % (fold)
\label{sub:discrete_surface_curve_data_structure}

  \begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{figures/surface-mesh-curve.pdf}
    \caption[Surface Mesh Curve]{%
      \textbf{Surface Mesh Curve}\\
    }
  \end{figure}

  \begin{figure}
    \centering
    \begin{subfigure}[b]{0.45\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/surface-mesh-curve-rot-left.pdf}
      \caption{Left}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/surface-mesh-curve-rot-right.pdf}
      \caption{Right}
    \end{subfigure}
    \caption[Right and Left Turn Scheme]{
      \textbf{Right and Left Turn Scheme}\\
    }
  \end{figure}

  \begin{figure}
    \centering
    \begin{subfigure}[c]{0.4\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/surface-mesh-curve-artifact.pdf}
    \end{subfigure}
    \hfill
    $\longrightarrow$
    \hfill
    \begin{subfigure}[c]{0.4\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/surface-mesh-curve-artifact-removed.pdf}
    \end{subfigure}
    \caption[Regularization of Irregular Triangle Paths]{
      \textbf{Regularization of Irregular Triangle Paths}\\
    }
  \end{figure}

  \begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{figures/unfolding-critical-vertex.pdf}
    \caption[Unfolding Critical Vertex]{%
      \textbf{Unfolding Critical Vertex}\\
    }
  \end{figure}

  There two main attempts for the construction of a data structure representing surface mesh curves.
  One of them is based on edges and the other on triangles.

  We do not look at polyhedral surfaces as an approximation of a real-world smooth manifold.

  Advantages of discrete surface mesh curves over more general curves on polyhedral surfaces
  \begin{itemize}
    \item Curve is provided in triangle precision. Better Compression. More points would be waste of memory.
    \item Robust: Snap to vertex if points get arbitrary near to each other
    \item curve is always a surface curve of the polyhedral surface and not violating mathematical properties. This also allows for direct rendering without projection.
    \item Useful for mesh processing
    \item Interpretation of Discretization is more consistent: surface mesh may be discretized approximationof real-world manifold with the mesh to be the finite grid. then it is only natural to discretize a real world surface curve in the same way.
  \end{itemize}

  Advantages of the triangular data structure over the edge-based one:
  \begin{itemize}
    \item Triangles can be easier generalized to higher dimensions than edges.
    \item Triangles do not need to handle boundaries in complicated ways.
    \item Triangles allow easy and ordered access to fan around vertex.
    \item Artifact removal routine for triangles is simpler than for edges.
    \item Triangles do not exhibit data loss when handling reflex vertices
    \item Triangles allow for a more general moving of points
  \end{itemize}
% subsection discrete_surface_curve_data_structure (end)

\subsection{Initial Curve Selection} % (fold)
\label{sub:initial_curve_selection}
  As for the vast majority of optimization algorithms, the results and efficient working are highly dependent on the chosen starting values.
  Curve smoothing itself is an optimization process and to solve the boundary value problem, we need an initial value.
  So, choosing the initial curve in the right way will also heavily change the speed and quality of the algorithm.
  The algorithm should be able to handle a vast amount unsmooth curves.
  Still, the handling of artifacts will be taken care of at the start.
  \paragraph{User Interface for Selecting and Controlling Initial Curves}
  \paragraph{Drawing by Ray Tracing}
  \paragraph{Connecting the Vertices}
  \paragraph{Closed Initial Curves and Fixed Vertices}
  \paragraph{Artifact Removal}
  \paragraph{Smoothed Curvature Values by Stencil}
    Stencil is discrete approximation of solution to Laplacian equation or heat equation which is smooth (infinitely differentiable).
    Maybe it would be useful to keep the length of the curve and still smooth it.
  \paragraph{Vertex Curves}
  \paragraph{Face Curves}
  \paragraph{Tracing Geodesics}
% subsection initial_curve_selection (end)

\subsection{Unfolding} % (fold)
\label{sub:unfolding}
To unfold two triangles along their common edge and find the shortest line connecting two points, we will first look back into two dimensions.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.6\linewidth]{figures/unfolding_geodesic_2d.pdf}
  \caption[2D Unfolding Primitive]{%
    \textbf{2D Unfolding Primitive}
  }
\end{figure}

Let $p,q\in\setReal^2$ such that $p_x < q_x$.
\[
  \Delta x = q_x - p_x
  \separate
  \Delta y = q_y - p_y
  \separate
  \Sigma x = p_x + q_x
  \separate
  \Sigma y = p_y + q_y
\]
The straight line function connecting these two points then looks like the following.
\[
  f(x) = \frac{q_y - p_y}{q_x - p_x}(x - p_x) + p_y = \frac{q_y - p_y}{q_x - p_x}x + \frac{p_yq_x - q_yp_x}{q_x - p_x}
\]
Please note that this function is well-defined, as $q_x - p_x > 0$.
To get the intersection point with the ordinate, set the argument to zero.
\[
  t\define f(0) = \frac{p_yq_x - q_yp_x}{q_x - p_x} = \frac{\Delta x \Sigma y - \Sigma x \Delta y}{2 \Delta x}
\]
\begin{figure}[h]
  \begin{subfigure}[b]{0.49\linewidth}
    \centering
    \includegraphics[width=0.9\linewidth]{figures/unfolding_geodesic.pdf}
    \caption{Folded in 3D space}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.49\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figures/unfolding_unfolded.pdf}
    \caption{Unfolded in 2D space}
  \end{subfigure}
  \caption[Unfolding of two Triangles]{%
    \textbf{Unfolding of two Triangles}
  }
  \label{fig:design-triangle-unfolding}
\end{figure}

Applying this expression to the case of two triangles that needs to be unfolded, the following results.
\[
  e \define \frac{v_2 - v_1}{\norm{v_2 - v_1}}
  \separate
  p \define r_1 - v_1
  \separate
  q \define r_2 - v_1
\]
\[
  p_y = \scalarProduct{e}{p}
  \separate
  q_y = \scalarProduct{e}{q}
\]
\[
  p_x = -\norm{p - p_y e}
  \separate
  q_x = \norm{q - q_y e}
\]
Unfolding two adjacent triangles that share a common edge from three-dimensional space into the two-dimensional plane is not unique as there are two cases.
In one case, the triangles might overlap and in the other not.
The above sign for $p_x$ is therefore important.

\begin{lemma}[Unfolding leads to geodesic]
  Connecting $p$, $r$, and $q$ in that order by straight lines leads to locally shortest and straightest geodesics as long as $λ\in (0,1)$.
  It solves the discrete boundary value problem for locally shortest and straightest geodesics when boundary points lie in the inside of adjacent triangles.
\end{lemma}
\begin{proof}
  According to \textcite{polthier2006} and \textcite{martinez2005}, locally shortest and straightest geodesics coincide on polyhedral if they do not contain any vertices.
  So, it is sufficient to show that the discrete curvature at the crease is zero.
  But this has be true by construction.
\end{proof}
% subsection unfolding (end)

\subsection{Unfolding with Desired Curvature} % (fold)
\label{sub:unfolding_with_desired_curvature}

  \begin{figure}[h]
    \centering
    \begin{subfigure}[b]{0.49\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/unfolding_curvature_2d.pdf}
      \caption{$κ < 0$}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.49\linewidth}
      \centering
      \includegraphics[width=\linewidth]{figures/unfolding_curvature_2d_positive.pdf}
      \caption{$κ > 0$}
    \end{subfigure}
    \caption[2D Unfolding Curvature Primitive]{%
      \textbf{2D Unfolding Curvature Primitive}\\
    }
    \label{fig:}
  \end{figure}

Again, a two-dimensional primitive is used.
\[
  f(x) = -\cot α (x - p_x) + p_y
\]
\[
  t = f(0) = p_y + \absolute{p_x}\cot α
\]
Now, combine two points to both sides with a desired discrete curvature.
For this, assume $p_x < 0$ and $q_x > 0$.
Furthermore, the desired curvature is positive $κ > 0$ and taken mathematically positive.
$α,β\in(0,π)$ and $κ\in(-π,π)$ with $κ < α$ and $π+κ > α$
\[
  κ + π = α + β
\]
From the former computation, it is clear that their points on the ordinate have to coincide.
\[
  p_y - p_x \cot α = q_y + q_x \cot β
\]
\[
  \cot β = \cot(π-(α-κ)) = -\cot(α-κ)
\]
\[
  \cot(α-κ) = \frac{\cos κ \cot α + \sin κ}{\cos κ - \sin κ \cot α}
\]
% \[
%   \cot(α-κ) = \frac{\cot α \cot κ + 1}{\cot κ - \cot α}
% \]
% \[
%   p_y - p_x \cot α = q_y - q_x \frac{\cot α \cot κ + 1}{\cot κ - \cot α}
% \]
\[
  φ\define \cot{α}
  % \separate
  % K\define \cot κ
\]
\[
  p_y - p_x φ = q_y - q_x \frac{φ \cos κ + \sin κ}{\cos κ - φ \sin κ}
\]
\[
  q_x \frac{φ \cos κ + \sin κ}{\cos κ - φ \sin κ} = q_y - p_y + p_x φ
\]
\[
  φ q_x \cos κ + q_x \sin κ
  = (\Delta y + φ p_x)(\cos κ - φ \sin κ)
\]
\[
  φ q_x \cos κ + q_x \sin κ
  = \Delta y \cos κ - φ \Delta y \sin κ + φ p_x \cos κ - φ^2 p_x \sin κ
\]
\[
  φ^2 p_x \sin κ + φ (\Delta x \cos κ + \Delta y \sin κ) + q_x \sin κ - \Delta y \cos κ = 0
\]
\[
  φ = \frac{1}{2 p_x \sin κ} \boxBrackets{-(\Delta x \cos κ + \Delta y \sin κ) \pm \sqrt{(\Delta x \cos κ + \Delta y \sin κ)^2 - 4p_x \sin κ (q_x \sin κ - \Delta y \cos κ)}}
\]
\[
  φ = \frac{1}{2 p_x \sin κ} \boxBrackets{-(\Delta x \cos κ + \Delta y \sin κ) \pm \sqrt{(\Sigma x \cos κ + \Delta y \sin κ)^2 - 4 p_x q_x}}
\]
\[
  t = \frac{1}{2 \sin κ} \boxBrackets{\Delta x \cos κ + \Sigma y \sin κ \pm \sqrt{(\Sigma x \cos κ + \Delta y \sin κ)^2 - 4 p_x q_x}}
\]
\[
  t = t_0 + \Delta t
\]
\[
  t = t_0 + \frac{1}{2 \sin κ} \boxBrackets{-2t_0\sin κ + \Delta x \cos κ + \Sigma y \sin κ \pm \sqrt{(\Sigma x \cos κ + \Delta y \sin κ)^2 - 4 p_x q_x}}
\]
\[
  t_0 = \frac{1}{2}(\Sigma y - \Sigma x \frac{\Delta y}{\Delta x})
\]
\[
  \Delta t = \frac{1}{2 \sin κ} \boxBrackets{\Sigma x \frac{\Delta y}{\Delta x}\sin κ + \Delta x \cos κ \pm \sqrt{(\Sigma x \cos κ + \Delta y \sin κ)^2 - 4 p_x q_x}}
\]
\[
  2 \Delta t \sin κ \leq 0
\]
\[
  \Delta t = \frac{1}{2 \sin κ} \boxBrackets{\Sigma x \frac{\Delta y}{\Delta x}\sin κ + \Delta x \cos κ - \sqrt{(\Sigma x \cos κ + \Delta y \sin κ)^2 - 4 p_x q_x}}
\]
% \[
%   Kq_xφ + q_x = \Delta y φ - K\Delta y + p_x φ^2 - Kp_x φ
% \]
% \[
%   q_x + K\Delta y = p_x φ^2 + (\Delta y -K(p_x+q_x))φ
% \]
% \[
%   \frac{q_x + K\Delta y}{p_x} = φ^2 + \frac{\Delta y - K\Sigma x}{p_x}φ
% \]
% \[
%   φ = -\frac{\Delta y - K\Sigma x}{2p_x} \pm \sqrt{\frac{q_x + K\Delta y}{p_x} + \frac{(\Delta y - K\Sigma x)^2}{4p^2_x}}
% \]
% \[
%   t = p_y - p_x φ
% \]
% \[
%   t = p_y + \frac{\Delta y - K\Sigma x}{2} \mp \sqrt{p_x(q_x + K\Delta y) + \frac{(\Delta y - K\Sigma x)^2}{4}}
% \]
% \[
%   t = \frac{\Sigma y - K\Sigma x}{2} \mp \sqrt{p_x(q_x + K\Delta y) + \frac{\Delta^2y - 2K\Delta y\Sigma x + K^2\Sigma^2x}{4}}
% \]
% \[
%   t = \frac{\Sigma y - K\Sigma x}{2} \mp \sqrt{p_xq_x(1 + K^2) + \frac{\Delta^2y - 2K\Delta y\Delta x + K^2\Delta^2x}{4}}
% \]
% \[
%   t = \frac{\Sigma y - K\Sigma x}{2} \mp \sqrt{p_xq_x(1 + K^2) + \frac{(\Delta y - K\Delta x)^2}{4}}
% \]
% subsection unfolding_with_desired_curvature (end)

\subsection{Desired Curvature Stencil} % (fold)
\label{sub:desired_curvature_stencil}

% subsection desired_curvature_stencil (end)

\subsection{Desired Curvature Mapping} % (fold)
\label{sub:desired_curvature_mapping}

% subsection desired_curvature_mapping (end)

\subsection{Curve Smoothing Algorithm} % (fold)
\label{sub:curve_smoothing_algorithm}
  Curve smoothing is not a discrete problem.
  Using only a finite amount of steps is probably not possible.
  So, we use a process of convergence.
  This has the advantage that not all triangles need to be unfolded at once.
  This makes the implementation and parallelization much simpler.
  The discrete algorithms for tracing geodesics are not easy to parallelize.

  \paragraph{Idea and Overview}
  \paragraph{Edge Vertex Relaxation}
    We need to take a look at topological and numerical robustness.
  \paragraph{Vertex Vertex Relaxation}
  \paragraph{Critical Vertex Handling}
  \paragraph{Artifact Removal and Self-Intersection Handling}
  \paragraph{Desired Curvature Mapping}
    Desired curvatures need to be constant along edges.
    Therefore interpolate on angle-basis around vertex.
    We do not want to loose information of desired curvatures.
  \paragraph{Curve Evaluation}
  \paragraph{Correctness and Convergence}
    Correctness can be shown by showing the convergence to the curvature values.
    This by definition of the given curvature values smooths the curve.
    The convergence might only be shown for contracting the curve by smoothing.
    As the limit is the geodesic, the prove of its convergence is there.
  \paragraph{Complexity}
% subsection curve_smoothing_algorithm (end)

% section design (end)
\end{document}
