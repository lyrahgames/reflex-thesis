\documentclass{stdlocal}
\begin{document}
\section{Design} % (fold)
\label{sec:design}

Experimenting with various designs and implementations of algorithms, that robustly and efficiently smooth discrete curves on surface meshes, requires us to use a whole computer graphics pipeline or framework for loading input data, intuitively working with user interaction, and visualizing any intermediate result.
As changing specific parts of such a pipeline may affect the performance, outcomes, and overall behavior of an algorithm or program, a brief overview over all of its components is essential to allow for reproducible results and will therefore be given in the following subsections.
This will also make it possible for readers to simply reconstruct, adjust, and improve the pipeline for their own domain-specific projects.
Afterwards, I will thoroughly elaborate on the design and implementation of chosen data structures and algorithms together with their mathematical primitives for curve smoothing.

The pipeline or framework, described in this thesis, has been manually implemented with the C++ programming language and the OpenGL graphics API using some external libraries to handle low-level tasks.
Already described in the introduction in section~\ref{sec:introduction}, this choice is well suited for open-source graphics applications and provides programmers with a large freedom when it comes to the implementation of data structures and algorithms.
The complete source code of the project, called \textit{nanoreflex}, is provided as an open-source repository on GitHub.

\subsection{Pipeline Overview} % (fold)
\label{sub:program_pipeline}
  In the following, the stages of the implemented program pipeline are stated and summarized.
  These stages naturally arise from an insight into the generation and tracing of geodesics on surface meshes, described in section~\ref{sec:previous_work}.
  Locally shortest or straightest geodesics that follow as a solution from the discrete boundary value problem are in some sense the smoothest curves that cannot be made any smoother.
  As we typically need to provide an initial curve for those geodesics to be found, the whole generation and tracing of geodesics can be looked at as an extreme smoothing process.
  Adding parameters to let the user decide on when to stop this process then results in the pipeline given below and schematically shown in figure~\ref{fig:program-pipeline}.

  \begin{figure}[h]
    \begin{center}
      \large
      INSERT YOUR IMAGE HERE!
    \end{center}
    \caption[Program Pipeline Stages]{%
      \textbf{Program Pipeline Stages}\\
      The scheme shows all the stages of the implemented program pipeline.
      The arrows indicate data flow and dependencies.
    }
    \label{fig:program-pipeline}
  \end{figure}

  \begin{enumerate}
    \item \textbf{Surface Mesh Loading:}\\
      Load a surface mesh given by a specific file format from the storage.
    \item \textbf{Surface Mesh Preprocessing:}
      \begin{enumerate}
        \item Generate a connected mesh object to properly model the topology of the input.
        \item Generate the pseudo-normals for each vertex.
        \item Generate the dual graph for the neighbors of each triangle.
        \item Check that the mesh is a valid orientable two-dimensional topological manifold.
      \end{enumerate}
    \item \textbf{Initial Curve Selection:} \\
      Let the user choose an initial curve by drawing on the surface.
    \item \textbf{Parameter Selection:} \\
      Let the user choose parameters for the curve smoothing algorithm.
    \item \textbf{Curve Smoothing:} \\
      Smooth the initial curve according to the constraints given by the selected parameters.
    \item \textbf{Postprocessing:} \\
      Optionally apply the smoothed curve in a domain-specific context.
  \end{enumerate}
  According to figure~\ref{fig:program-pipeline}, the output of every stage is not only forwarded to the next stage but also specifically visualized and rendered to the screen to provide the user with visual feedback and to catch errors or exceptional behavior as early as possible.
  Besides, additional user interactions will be processed for all stages to allow for measurements and adjustments and to be able to react to the output of previous stages.
  The loading of surface meshes from different file formats is typically handled by loader libraries, such as \textit{Assimp}, and will not be further explained.
  On the other hand, surface mesh preprocessing and the initial curve selection are crucial steps in the whole pipeline which remove geometric degeneracies and artifacts that would otherwise violate assertions needed for the correct execution of the algorithm.
  Therefore both stages will be discussed in more detail in the following subsections.
  The postprocessing in our case is optional and only provided for the sake of completeness.
  The parameter selection is highly dependent on the implementation of the curve smoothing algorithm and, as a result, it will be described together with the curve smoothing itself.
% subsection program_pipeline (end)

\subsection{Mesh Preprocessing} % (fold)
\label{sub:mesh_preprocessing}
  We need the topological connections of a given surface mesh.
  In the case of general file formats, a scene is typically separated into multiple meshes which are topologically but not smoothly connected.
  For proper drawing of curves in a whole scene, the topological structure of connections needs to be generated first.
  Using the STL file format, this is not needed.
  A given Mesh for the algorithm can be quite general.
  Providing triangles which will introduce numerical difficulties is out of the scope of this thesis.
  We will focus on orientable meshes.
  Please note, that is not an actual restriction for the algorithm but will only speed up the implementation.
  Furthermore, we look at surfaces which are the boundary of volumes in three-dimensional Euclidean space which can be looked at as open submanifolds.
  These volumes are therefore by definition oriented and, hence, their boundary needs to be, too.
  Still, we need to look boundaries for surfaces as, for example, distance envelopes restrict the surface without boundary to be one.
  The boundaries need to be handled properly.
  Also, these requirements are only need to hold for the restriction to the distance envelope.
  Often, lines will be drawn on oriented/orientable parts of the surface even if the surface is not orientable due to artifacts originating from scanning or generating meshes.
% subsection mesh_preprocessing (end)

\subsection{Initial Curve Selection} % (fold)
\label{sub:initial_curve_selection}
  As for the vast majority of optimization algorithms, the results and efficient working are highly dependent on the chosen starting values.
  Curve smoothing itself is an optimization process and to solve the boundary value problem, we need an initial value.
  So, choosing the initial curve in the right way will also heavily change the speed and quality of the algorithm.
  The algorithm should be able to handle a vast amount unsmooth curves.
  Still, the handling of artifacts will be taken care of at the start.
  \paragraph{User Interface for Selecting and Controlling Initial Curves}
  \paragraph{Drawing by Ray Tracing}
  \paragraph{Connecting the Vertices}
  \paragraph{Closed Initial Curves and Fixed Vertices}
  \paragraph{Artifact Removal}
  \paragraph{Smoothed Curvature Values by Stencil}
    Stencil is discrete approximation of solution to Laplacian equation or heat equation which is smooth (infinitely differentiable).
    Maybe it would be useful to keep the length of the curve and still smooth it.
  \paragraph{Vertex Curves}
  \paragraph{Face Curves}
  \paragraph{Tracing Geodesics}
% subsection initial_curve_selection (end)

\subsection{Curve Smoothing Algorithm} % (fold)
\label{sub:curve_smoothing_algorithm}
  \paragraph{Idea and Overview}
  \paragraph{Edge Vertex Relaxation}
    We need to take a look at topological and numerical robustness.
  \paragraph{Vertex Vertex Relaxation}
  \paragraph{Critical Vertex Handling}
  \paragraph{Artifact Removal and Self-Intersection Handling}
  \paragraph{Desired Curvature Mapping}
    Desired curvatures need to be constant along edges.
    Therefore interpolate on angle-basis around vertex.
    We do not want to loose information of desired curvatures.
  \paragraph{Curve Evaluation}
  \paragraph{Correctness and Convergence}
    Correctness can be shown by showing the convergence to the curvature values.
    This by definition of the given curvature values smooths the curve.
    The convergence might only be shown for contracting the curve by smoothing.
    As the limit is the geodesic, the prove of its convergence is there.
  \paragraph{Complexity}
% subsection curve_smoothing_algorithm (end)

% section design (end)
\end{document}
